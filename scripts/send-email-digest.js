#!/usr/bin/env node

import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Email service configuration
const RESEND_API_KEY = process.env.RESEND_API_KEY;
const FROM_EMAIL = process.env.FROM_EMAIL || 'noreply@queerjews.com';
const RESEND_CONTACT_LIST_ID = process.env.RESEND_CONTACT_LIST_ID;

class EmailDigestError extends Error {
  constructor(message, code = 'UNKNOWN_ERROR') {
    super(message);
    this.name = 'EmailDigestError';
    this.code = code;
  }
}

async function fetchSubscriptions() {
  try {
    const response = await fetch(`https://api.resend.com/contacts?audienceId=${RESEND_CONTACT_LIST_ID}`, {
      headers: {
        'Authorization': `Bearer ${RESEND_API_KEY}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Resend API error: ${error.message}`);
    }

    const data = await response.json();
    
    // Filter out unsubscribed contacts and map to our format
    return data.data
      .filter(contact => !contact.unsubscribed)
      .map(contact => ({
        email: contact.email,
        frequency: contact.metadata?.frequency || 'weekly',
        timestamp: contact.metadata?.subscribedAt || contact.createdAt
      }));
  } catch (error) {
    throw new EmailDigestError(
      `Failed to fetch subscriptions: ${error.message}`,
      'API_ERROR'
    );
  }
}

async function fetchRecentPersonals(days = 7) {
  try {
    // For now, we'll read from the JSON file that's generated by your sync process
    // In the future, you could move this to a database or API
    const fs = await import('fs/promises');
    const path = await import('path');
    const { fileURLToPath } = await import('url');
    
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const personalsFile = path.join(__dirname, '../src/data/personals.json');
    
    const personalsData = JSON.parse(await fs.readFile(personalsFile, 'utf8'));
    
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);

    return personalsData
      .filter(personal => {
        const personalDate = new Date(personal.date_posted);
        return personalDate >= cutoffDate;
      })
      .map(personal => ({
        title: personal.title || 'Untitled',
        body: personal.personal || '',
        timestamp: personal.date_posted
      }));
  } catch (error) {
    throw new EmailDigestError(
      `Failed to fetch personals: ${error.message}`,
      'API_ERROR'
    );
  }
}

async function sendEmail(to, subject, htmlContent) {
  try {
    // Using Resend API (free tier: 3,000 emails/month)
    const response = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${RESEND_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        from: FROM_EMAIL,
        to: [to],
        subject: subject,
        html: htmlContent,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Resend API error: ${error.message}`);
    }

    return await response.json();
  } catch (error) {
    throw new EmailDigestError(
      `Failed to send email: ${error.message}`,
      'EMAIL_ERROR'
    );
  }
}

function generateDigestHTML(personals, frequency) {
  const frequencyText = frequency === 'weekly' ? 'Weekly' : 'Monthly';
  const personalCount = personals.length;
  
  let html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #aaf0d1; padding: 20px; text-align: center; border-radius: 8px; margin-bottom: 30px; }
        .personal { background-color: #f9f9f9; padding: 20px; margin-bottom: 20px; border-radius: 8px; border-left: 4px solid #aaf0d1; }
        .personal-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; color: #2d3748; }
        .personal-body { margin-bottom: 15px; }
        .personal-date { font-size: 12px; color: #718096; }
        .footer { text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #e2e8f0; font-size: 14px; color: #718096; }
        .unsubscribe { color: #aaf0d1; text-decoration: none; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Queer Jews Personals</h1>
        <p>${frequencyText} Digest</p>
      </div>
  `;

  if (personals.length === 0) {
    html += `
      <p>No new personals this ${frequency === 'weekly' ? 'week' : 'month'}.</p>
      <p>Check back soon for new connections!</p>
    `;
  } else {
    html += `<p>Here are ${personalCount} new personal${personalCount === 1 ? '' : 's'} from the past ${frequency === 'weekly' ? 'week' : 'month'}:</p>`;
    
    personals.forEach(personal => {
      const date = new Date(personal.timestamp).toLocaleDateString();
      html += `
        <div class="personal">
          <div class="personal-title">${personal.title}</div>
          <div class="personal-body">${personal.body}</div>
          <div class="personal-date">Posted on ${date}</div>
        </div>
      `;
    });
  }

  html += `
      <div class="footer">
        <p>üíö Built with love for the queer Jewish community</p>
        <p><a href="https://queerjews.com" class="unsubscribe">Browse all personals</a> | 
           <a href="https://queerjews.com/submit" class="unsubscribe">Submit your own</a></p>
        <p><a href="[UNSUBSCRIBE_URL]" class="unsubscribe">Unsubscribe</a></p>
      </div>
    </body>
    </html>
  `;

  return html;
}

async function sendDigestEmails(frequency = 'weekly') {
  try {
    console.log(`üìß Starting ${frequency} digest email process...`);

    // Fetch data
    const subscriptions = await fetchSubscriptions();
    const personals = await fetchRecentPersonals(frequency === 'weekly' ? 7 : 30);

    // Filter subscriptions by frequency
    const relevantSubscriptions = subscriptions.filter(sub => sub.frequency === frequency);
    
    console.log(`üìä Found ${relevantSubscriptions.length} ${frequency} subscribers`);
    console.log(`üìù Found ${personals.length} recent personals`);

    if (relevantSubscriptions.length === 0) {
      console.log('‚úÖ No subscribers for this frequency, skipping...');
      return;
    }

    // Generate email content
    const subject = `Queer Jews Personals - ${frequency === 'weekly' ? 'Weekly' : 'Monthly'} Digest`;
    const htmlContent = generateDigestHTML(personals, frequency);

    // Send emails
    let successCount = 0;
    let errorCount = 0;

    for (const subscription of relevantSubscriptions) {
      try {
        await sendEmail(subscription.email, subject, htmlContent);
        successCount++;
        console.log(`‚úÖ Sent digest to ${subscription.email}`);
      } catch (error) {
        errorCount++;
        console.error(`‚ùå Failed to send to ${subscription.email}: ${error.message}`);
      }
    }

    console.log(`üéâ Digest complete: ${successCount} sent, ${errorCount} failed`);

  } catch (error) {
    console.error(`‚ùå Digest failed: ${error.message}`);
    throw error;
  }
}

// CLI interface
async function main() {
  const frequency = process.argv[2] || 'weekly';
  
  if (!['weekly', 'monthly'].includes(frequency)) {
    console.error('Usage: node send-email-digest.js [weekly|monthly]');
    process.exit(1);
  }

  try {
    await sendDigestEmails(frequency);
    console.log('‚úÖ Email digest process completed successfully');
  } catch (error) {
    console.error(`‚ùå Email digest failed: ${error.message}`);
    process.exit(1);
  }
}

// Export for testing
export { sendDigestEmails, generateDigestHTML };

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
} 